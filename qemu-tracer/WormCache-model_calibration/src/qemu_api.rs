/* automatically generated by rust-bindgen 0.68.1 */
#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

/**
 * Warning: This file does not define the same plugin system as the official.
 * It must be used together with PARSA QEMU (https://github.com/parsa-epfl/qemu). 
 */

pub const _INTTYPES_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C2X_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 38;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &[u8; 2] = b"l\0";
pub const __PRIPTR_PREFIX: &[u8; 2] = b"l\0";
pub const PRId8: &[u8; 2] = b"d\0";
pub const PRId16: &[u8; 2] = b"d\0";
pub const PRId32: &[u8; 2] = b"d\0";
pub const PRId64: &[u8; 3] = b"ld\0";
pub const PRIdLEAST8: &[u8; 2] = b"d\0";
pub const PRIdLEAST16: &[u8; 2] = b"d\0";
pub const PRIdLEAST32: &[u8; 2] = b"d\0";
pub const PRIdLEAST64: &[u8; 3] = b"ld\0";
pub const PRIdFAST8: &[u8; 2] = b"d\0";
pub const PRIdFAST16: &[u8; 3] = b"ld\0";
pub const PRIdFAST32: &[u8; 3] = b"ld\0";
pub const PRIdFAST64: &[u8; 3] = b"ld\0";
pub const PRIi8: &[u8; 2] = b"i\0";
pub const PRIi16: &[u8; 2] = b"i\0";
pub const PRIi32: &[u8; 2] = b"i\0";
pub const PRIi64: &[u8; 3] = b"li\0";
pub const PRIiLEAST8: &[u8; 2] = b"i\0";
pub const PRIiLEAST16: &[u8; 2] = b"i\0";
pub const PRIiLEAST32: &[u8; 2] = b"i\0";
pub const PRIiLEAST64: &[u8; 3] = b"li\0";
pub const PRIiFAST8: &[u8; 2] = b"i\0";
pub const PRIiFAST16: &[u8; 3] = b"li\0";
pub const PRIiFAST32: &[u8; 3] = b"li\0";
pub const PRIiFAST64: &[u8; 3] = b"li\0";
pub const PRIo8: &[u8; 2] = b"o\0";
pub const PRIo16: &[u8; 2] = b"o\0";
pub const PRIo32: &[u8; 2] = b"o\0";
pub const PRIo64: &[u8; 3] = b"lo\0";
pub const PRIoLEAST8: &[u8; 2] = b"o\0";
pub const PRIoLEAST16: &[u8; 2] = b"o\0";
pub const PRIoLEAST32: &[u8; 2] = b"o\0";
pub const PRIoLEAST64: &[u8; 3] = b"lo\0";
pub const PRIoFAST8: &[u8; 2] = b"o\0";
pub const PRIoFAST16: &[u8; 3] = b"lo\0";
pub const PRIoFAST32: &[u8; 3] = b"lo\0";
pub const PRIoFAST64: &[u8; 3] = b"lo\0";
pub const PRIu8: &[u8; 2] = b"u\0";
pub const PRIu16: &[u8; 2] = b"u\0";
pub const PRIu32: &[u8; 2] = b"u\0";
pub const PRIu64: &[u8; 3] = b"lu\0";
pub const PRIuLEAST8: &[u8; 2] = b"u\0";
pub const PRIuLEAST16: &[u8; 2] = b"u\0";
pub const PRIuLEAST32: &[u8; 2] = b"u\0";
pub const PRIuLEAST64: &[u8; 3] = b"lu\0";
pub const PRIuFAST8: &[u8; 2] = b"u\0";
pub const PRIuFAST16: &[u8; 3] = b"lu\0";
pub const PRIuFAST32: &[u8; 3] = b"lu\0";
pub const PRIuFAST64: &[u8; 3] = b"lu\0";
pub const PRIx8: &[u8; 2] = b"x\0";
pub const PRIx16: &[u8; 2] = b"x\0";
pub const PRIx32: &[u8; 2] = b"x\0";
pub const PRIx64: &[u8; 3] = b"lx\0";
pub const PRIxLEAST8: &[u8; 2] = b"x\0";
pub const PRIxLEAST16: &[u8; 2] = b"x\0";
pub const PRIxLEAST32: &[u8; 2] = b"x\0";
pub const PRIxLEAST64: &[u8; 3] = b"lx\0";
pub const PRIxFAST8: &[u8; 2] = b"x\0";
pub const PRIxFAST16: &[u8; 3] = b"lx\0";
pub const PRIxFAST32: &[u8; 3] = b"lx\0";
pub const PRIxFAST64: &[u8; 3] = b"lx\0";
pub const PRIX8: &[u8; 2] = b"X\0";
pub const PRIX16: &[u8; 2] = b"X\0";
pub const PRIX32: &[u8; 2] = b"X\0";
pub const PRIX64: &[u8; 3] = b"lX\0";
pub const PRIXLEAST8: &[u8; 2] = b"X\0";
pub const PRIXLEAST16: &[u8; 2] = b"X\0";
pub const PRIXLEAST32: &[u8; 2] = b"X\0";
pub const PRIXLEAST64: &[u8; 3] = b"lX\0";
pub const PRIXFAST8: &[u8; 2] = b"X\0";
pub const PRIXFAST16: &[u8; 3] = b"lX\0";
pub const PRIXFAST32: &[u8; 3] = b"lX\0";
pub const PRIXFAST64: &[u8; 3] = b"lX\0";
pub const PRIdMAX: &[u8; 3] = b"ld\0";
pub const PRIiMAX: &[u8; 3] = b"li\0";
pub const PRIoMAX: &[u8; 3] = b"lo\0";
pub const PRIuMAX: &[u8; 3] = b"lu\0";
pub const PRIxMAX: &[u8; 3] = b"lx\0";
pub const PRIXMAX: &[u8; 3] = b"lX\0";
pub const PRIdPTR: &[u8; 3] = b"ld\0";
pub const PRIiPTR: &[u8; 3] = b"li\0";
pub const PRIoPTR: &[u8; 3] = b"lo\0";
pub const PRIuPTR: &[u8; 3] = b"lu\0";
pub const PRIxPTR: &[u8; 3] = b"lx\0";
pub const PRIXPTR: &[u8; 3] = b"lX\0";
pub const SCNd8: &[u8; 4] = b"hhd\0";
pub const SCNd16: &[u8; 3] = b"hd\0";
pub const SCNd32: &[u8; 2] = b"d\0";
pub const SCNd64: &[u8; 3] = b"ld\0";
pub const SCNdLEAST8: &[u8; 4] = b"hhd\0";
pub const SCNdLEAST16: &[u8; 3] = b"hd\0";
pub const SCNdLEAST32: &[u8; 2] = b"d\0";
pub const SCNdLEAST64: &[u8; 3] = b"ld\0";
pub const SCNdFAST8: &[u8; 4] = b"hhd\0";
pub const SCNdFAST16: &[u8; 3] = b"ld\0";
pub const SCNdFAST32: &[u8; 3] = b"ld\0";
pub const SCNdFAST64: &[u8; 3] = b"ld\0";
pub const SCNi8: &[u8; 4] = b"hhi\0";
pub const SCNi16: &[u8; 3] = b"hi\0";
pub const SCNi32: &[u8; 2] = b"i\0";
pub const SCNi64: &[u8; 3] = b"li\0";
pub const SCNiLEAST8: &[u8; 4] = b"hhi\0";
pub const SCNiLEAST16: &[u8; 3] = b"hi\0";
pub const SCNiLEAST32: &[u8; 2] = b"i\0";
pub const SCNiLEAST64: &[u8; 3] = b"li\0";
pub const SCNiFAST8: &[u8; 4] = b"hhi\0";
pub const SCNiFAST16: &[u8; 3] = b"li\0";
pub const SCNiFAST32: &[u8; 3] = b"li\0";
pub const SCNiFAST64: &[u8; 3] = b"li\0";
pub const SCNu8: &[u8; 4] = b"hhu\0";
pub const SCNu16: &[u8; 3] = b"hu\0";
pub const SCNu32: &[u8; 2] = b"u\0";
pub const SCNu64: &[u8; 3] = b"lu\0";
pub const SCNuLEAST8: &[u8; 4] = b"hhu\0";
pub const SCNuLEAST16: &[u8; 3] = b"hu\0";
pub const SCNuLEAST32: &[u8; 2] = b"u\0";
pub const SCNuLEAST64: &[u8; 3] = b"lu\0";
pub const SCNuFAST8: &[u8; 4] = b"hhu\0";
pub const SCNuFAST16: &[u8; 3] = b"lu\0";
pub const SCNuFAST32: &[u8; 3] = b"lu\0";
pub const SCNuFAST64: &[u8; 3] = b"lu\0";
pub const SCNo8: &[u8; 4] = b"hho\0";
pub const SCNo16: &[u8; 3] = b"ho\0";
pub const SCNo32: &[u8; 2] = b"o\0";
pub const SCNo64: &[u8; 3] = b"lo\0";
pub const SCNoLEAST8: &[u8; 4] = b"hho\0";
pub const SCNoLEAST16: &[u8; 3] = b"ho\0";
pub const SCNoLEAST32: &[u8; 2] = b"o\0";
pub const SCNoLEAST64: &[u8; 3] = b"lo\0";
pub const SCNoFAST8: &[u8; 4] = b"hho\0";
pub const SCNoFAST16: &[u8; 3] = b"lo\0";
pub const SCNoFAST32: &[u8; 3] = b"lo\0";
pub const SCNoFAST64: &[u8; 3] = b"lo\0";
pub const SCNx8: &[u8; 4] = b"hhx\0";
pub const SCNx16: &[u8; 3] = b"hx\0";
pub const SCNx32: &[u8; 2] = b"x\0";
pub const SCNx64: &[u8; 3] = b"lx\0";
pub const SCNxLEAST8: &[u8; 4] = b"hhx\0";
pub const SCNxLEAST16: &[u8; 3] = b"hx\0";
pub const SCNxLEAST32: &[u8; 2] = b"x\0";
pub const SCNxLEAST64: &[u8; 3] = b"lx\0";
pub const SCNxFAST8: &[u8; 4] = b"hhx\0";
pub const SCNxFAST16: &[u8; 3] = b"lx\0";
pub const SCNxFAST32: &[u8; 3] = b"lx\0";
pub const SCNxFAST64: &[u8; 3] = b"lx\0";
pub const SCNdMAX: &[u8; 3] = b"ld\0";
pub const SCNiMAX: &[u8; 3] = b"li\0";
pub const SCNoMAX: &[u8; 3] = b"lo\0";
pub const SCNuMAX: &[u8; 3] = b"lu\0";
pub const SCNxMAX: &[u8; 3] = b"lx\0";
pub const SCNdPTR: &[u8; 3] = b"ld\0";
pub const SCNiPTR: &[u8; 3] = b"li\0";
pub const SCNoPTR: &[u8; 3] = b"lo\0";
pub const SCNuPTR: &[u8; 3] = b"lu\0";
pub const SCNxPTR: &[u8; 3] = b"lx\0";
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const QEMU_PLUGIN_VERSION: u32 = 1;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type __gwchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<imaxdiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
#[doc = " typedef qemu_plugin_id_t - Unique plugin ID"]
pub type qemu_plugin_id_t = u64;
extern "C" {
    pub static mut qemu_plugin_version: ::std::os::raw::c_int;
}
#[doc = " struct qemu_info_t - system information for plugins\n\n This structure provides for some limited information about the\n system to allow the plugin to make decisions on how to proceed. For\n example it might only be suitable for running on some guest\n architectures or when under full system emulation."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qemu_info_t {
    #[doc = " @target_name: string describing architecture"]
    pub target_name: *const ::std::os::raw::c_char,
    pub version: qemu_info_t__bindgen_ty_1,
    #[doc = " @system_emulation: is this a full system emulation?"]
    pub system_emulation: bool,
    pub __bindgen_anon_1: qemu_info_t__bindgen_ty_2,
}
#[doc = " @version: minimum and current plugin API level"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qemu_info_t__bindgen_ty_1 {
    pub min: ::std::os::raw::c_int,
    pub cur: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_qemu_info_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<qemu_info_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qemu_info_t__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(qemu_info_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<qemu_info_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(qemu_info_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qemu_info_t__bindgen_ty_1),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cur) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(qemu_info_t__bindgen_ty_1),
            "::",
            stringify!(cur)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union qemu_info_t__bindgen_ty_2 {
    pub system: qemu_info_t__bindgen_ty_2__bindgen_ty_1,
}
#[doc = " @system: information relevant to system emulation"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qemu_info_t__bindgen_ty_2__bindgen_ty_1 {
    #[doc = " @system.smp_vcpus: initial number of vCPUs"]
    pub smp_vcpus: ::std::os::raw::c_int,
    #[doc = " @system.max_vcpus: maximum possible number of vCPUs"]
    pub max_vcpus: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_qemu_info_t__bindgen_ty_2__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<qemu_info_t__bindgen_ty_2__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qemu_info_t__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(qemu_info_t__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<qemu_info_t__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(qemu_info_t__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).smp_vcpus) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qemu_info_t__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(smp_vcpus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_vcpus) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(qemu_info_t__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(max_vcpus)
        )
    );
}
#[test]
fn bindgen_test_layout_qemu_info_t__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<qemu_info_t__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qemu_info_t__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(qemu_info_t__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<qemu_info_t__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(qemu_info_t__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).system) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qemu_info_t__bindgen_ty_2),
            "::",
            stringify!(system)
        )
    );
}
#[test]
fn bindgen_test_layout_qemu_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<qemu_info_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qemu_info_t>(),
        32usize,
        concat!("Size of: ", stringify!(qemu_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<qemu_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(qemu_info_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qemu_info_t),
            "::",
            stringify!(target_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qemu_info_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).system_emulation) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(qemu_info_t),
            "::",
            stringify!(system_emulation)
        )
    );
}
extern "C" {
    #[doc = " qemu_plugin_install() - Install a plugin\n @id: this plugin's opaque ID\n @info: a block describing some details about the guest\n @argc: number of arguments\n @argv: array of arguments (@argc elements)\n\n All plugins must export this symbol which is called when the plugin\n is first loaded. Calling qemu_plugin_uninstall() from this function\n is a bug.\n\n Note: @info is only live during the call. Copy any information we\n want to keep. @argv remains valid throughout the lifetime of the\n loaded plugin.\n\n Return: 0 on successful loading, !0 for an error."]
    pub fn qemu_plugin_install(
        id: qemu_plugin_id_t,
        info: *const qemu_info_t,
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[doc = " typedef qemu_plugin_simple_cb_t - simple callback\n @id: the unique qemu_plugin_id_t\n\n This callback passes no information aside from the unique @id."]
pub type qemu_plugin_simple_cb_t =
    ::std::option::Option<unsafe extern "C" fn(id: qemu_plugin_id_t)>;
#[doc = " typedef qemu_plugin_udata_cb_t - callback with user data\n @id: the unique qemu_plugin_id_t\n @userdata: a pointer to some user data supplied when the callback\n was registered."]
pub type qemu_plugin_udata_cb_t = ::std::option::Option<
    unsafe extern "C" fn(id: qemu_plugin_id_t, userdata: *mut ::std::os::raw::c_void),
>;
#[doc = " typedef qemu_plugin_vcpu_simple_cb_t - vcpu callback\n @id: the unique qemu_plugin_id_t\n @vcpu_index: the current vcpu context"]
pub type qemu_plugin_vcpu_simple_cb_t = ::std::option::Option<
    unsafe extern "C" fn(id: qemu_plugin_id_t, vcpu_index: ::std::os::raw::c_uint),
>;
#[doc = " typedef qemu_plugin_vcpu_udata_cb_t - vcpu callback\n @vcpu_index: the current vcpu context\n @userdata: a pointer to some user data supplied when the callback\n was registered."]
pub type qemu_plugin_vcpu_udata_cb_t = ::std::option::Option<
    unsafe extern "C" fn(vcpu_index: ::std::os::raw::c_uint, userdata: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " qemu_plugin_uninstall() - Uninstall a plugin\n @id: this plugin's opaque ID\n @cb: callback to be called once the plugin has been removed\n\n Do NOT assume that the plugin has been uninstalled once this function\n returns. Plugins are uninstalled asynchronously, and therefore the given\n plugin receives callbacks until @cb is called.\n\n Note: Calling this function from qemu_plugin_install() is a bug."]
    pub fn qemu_plugin_uninstall(id: qemu_plugin_id_t, cb: qemu_plugin_simple_cb_t);
}
extern "C" {
    #[doc = " qemu_plugin_reset() - Reset a plugin\n @id: this plugin's opaque ID\n @cb: callback to be called once the plugin has been reset\n\n Unregisters all callbacks for the plugin given by @id.\n\n Do NOT assume that the plugin has been reset once this function returns.\n Plugins are reset asynchronously, and therefore the given plugin receives\n callbacks until @cb is called."]
    pub fn qemu_plugin_reset(id: qemu_plugin_id_t, cb: qemu_plugin_simple_cb_t);
}
extern "C" {
    #[doc = " qemu_plugin_register_vcpu_init_cb() - register a vCPU initialization callback\n @id: plugin ID\n @cb: callback function\n\n The @cb function is called every time a vCPU is initialized.\n\n See also: qemu_plugin_register_vcpu_exit_cb()"]
    pub fn qemu_plugin_register_vcpu_init_cb(
        id: qemu_plugin_id_t,
        cb: qemu_plugin_vcpu_simple_cb_t,
    );
}
extern "C" {
    #[doc = " qemu_plugin_register_vcpu_exit_cb() - register a vCPU exit callback\n @id: plugin ID\n @cb: callback function\n\n The @cb function is called every time a vCPU exits.\n\n See also: qemu_plugin_register_vcpu_init_cb()"]
    pub fn qemu_plugin_register_vcpu_exit_cb(
        id: qemu_plugin_id_t,
        cb: qemu_plugin_vcpu_simple_cb_t,
    );
}
extern "C" {
    #[doc = " qemu_plugin_register_vcpu_idle_cb() - register a vCPU idle callback\n @id: plugin ID\n @cb: callback function\n\n The @cb function is called every time a vCPU idles."]
    pub fn qemu_plugin_register_vcpu_idle_cb(
        id: qemu_plugin_id_t,
        cb: qemu_plugin_vcpu_simple_cb_t,
    );
}
extern "C" {
    #[doc = " qemu_plugin_register_vcpu_resume_cb() - register a vCPU resume callback\n @id: plugin ID\n @cb: callback function\n\n The @cb function is called every time a vCPU resumes execution."]
    pub fn qemu_plugin_register_vcpu_resume_cb(
        id: qemu_plugin_id_t,
        cb: qemu_plugin_vcpu_simple_cb_t,
    );
}
#[doc = " struct qemu_plugin_tb - Opaque handle for a translation block"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qemu_plugin_tb {
    _unused: [u8; 0],
}
#[doc = " struct qemu_plugin_insn - Opaque handle for a translated instruction"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qemu_plugin_insn {
    _unused: [u8; 0],
}
pub const qemu_plugin_cb_flags_QEMU_PLUGIN_CB_NO_REGS: qemu_plugin_cb_flags = 0;
pub const qemu_plugin_cb_flags_QEMU_PLUGIN_CB_R_REGS: qemu_plugin_cb_flags = 1;
pub const qemu_plugin_cb_flags_QEMU_PLUGIN_CB_RW_REGS: qemu_plugin_cb_flags = 2;
#[doc = " enum qemu_plugin_cb_flags - type of callback\n\n @QEMU_PLUGIN_CB_NO_REGS: callback does not access the CPU's regs\n @QEMU_PLUGIN_CB_R_REGS: callback reads the CPU's regs\n @QEMU_PLUGIN_CB_RW_REGS: callback reads and writes the CPU's regs\n\n Note: currently unused, plugins cannot read or change system\n register state."]
pub type qemu_plugin_cb_flags = ::std::os::raw::c_uint;
pub const qemu_plugin_mem_rw_QEMU_PLUGIN_MEM_R: qemu_plugin_mem_rw = 1;
pub const qemu_plugin_mem_rw_QEMU_PLUGIN_MEM_W: qemu_plugin_mem_rw = 2;
pub const qemu_plugin_mem_rw_QEMU_PLUGIN_MEM_RW: qemu_plugin_mem_rw = 3;
pub type qemu_plugin_mem_rw = ::std::os::raw::c_uint;
#[doc = " typedef qemu_plugin_vcpu_tb_trans_cb_t - translation callback\n @id: unique plugin id\n @tb: opaque handle used for querying and instrumenting a block."]
pub type qemu_plugin_vcpu_tb_trans_cb_t =
    ::std::option::Option<unsafe extern "C" fn(id: qemu_plugin_id_t, tb: *mut qemu_plugin_tb)>;
extern "C" {
    #[doc = " qemu_plugin_register_vcpu_tb_trans_cb() - register a translate cb\n @id: plugin ID\n @cb: callback function\n\n The @cb function is called every time a translation occurs. The @cb\n function is passed an opaque qemu_plugin_type which it can query\n for additional information including the list of translated\n instructions. At this point the plugin can register further\n callbacks to be triggered when the block or individual instruction\n executes."]
    pub fn qemu_plugin_register_vcpu_tb_trans_cb(
        id: qemu_plugin_id_t,
        cb: qemu_plugin_vcpu_tb_trans_cb_t,
    );
}
extern "C" {
    #[doc = " qemu_plugin_register_vcpu_tb_exec_cb() - register execution callback\n @tb: the opaque qemu_plugin_tb handle for the translation\n @cb: callback function\n @flags: does the plugin read or write the CPU's registers?\n @userdata: any plugin data to pass to the @cb?\n\n The @cb function is called every time a translated unit executes."]
    pub fn qemu_plugin_register_vcpu_tb_exec_cb(
        tb: *mut qemu_plugin_tb,
        cb: qemu_plugin_vcpu_udata_cb_t,
        flags: qemu_plugin_cb_flags,
        userdata: *mut ::std::os::raw::c_void,
    );
}
pub const qemu_plugin_op_QEMU_PLUGIN_INLINE_ADD_U64: qemu_plugin_op = 0;
#[doc = " enum qemu_plugin_op - describes an inline op\n\n @QEMU_PLUGIN_INLINE_ADD_U64: add an immediate value uint64_t\n\n Note: currently only a single inline op is supported."]
pub type qemu_plugin_op = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " qemu_plugin_register_vcpu_tb_exec_inline() - execution inline op\n @tb: the opaque qemu_plugin_tb handle for the translation\n @op: the type of qemu_plugin_op (e.g. ADD_U64)\n @ptr: the target memory location for the op\n @imm: the op data (e.g. 1)\n\n Insert an inline op to every time a translated unit executes.\n Useful if you just want to increment a single counter somewhere in\n memory.\n\n Note: ops are not atomic so in multi-threaded/multi-smp situations\n you will get inexact results."]
    pub fn qemu_plugin_register_vcpu_tb_exec_inline(
        tb: *mut qemu_plugin_tb,
        op: qemu_plugin_op,
        ptr: *mut ::std::os::raw::c_void,
        imm: u64,
    );
}
extern "C" {
    #[doc = " qemu_plugin_register_vcpu_insn_exec_cb() - register insn execution cb\n @insn: the opaque qemu_plugin_insn handle for an instruction\n @cb: callback function\n @flags: does the plugin read or write the CPU's registers?\n @userdata: any plugin data to pass to the @cb?\n\n The @cb function is called every time an instruction is executed"]
    pub fn qemu_plugin_register_vcpu_insn_exec_cb(
        insn: *mut qemu_plugin_insn,
        cb: qemu_plugin_vcpu_udata_cb_t,
        flags: qemu_plugin_cb_flags,
        userdata: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " qemu_plugin_register_vcpu_insn_exec_inline() - insn execution inline op\n @insn: the opaque qemu_plugin_insn handle for an instruction\n @op: the type of qemu_plugin_op (e.g. ADD_U64)\n @ptr: the target memory location for the op\n @imm: the op data (e.g. 1)\n\n Insert an inline op to every time an instruction executes. Useful\n if you just want to increment a single counter somewhere in memory."]
    pub fn qemu_plugin_register_vcpu_insn_exec_inline(
        insn: *mut qemu_plugin_insn,
        op: qemu_plugin_op,
        ptr: *mut ::std::os::raw::c_void,
        imm: u64,
    );
}
extern "C" {
    #[doc = " qemu_plugin_tb_n_insns() - query helper for number of insns in TB\n @tb: opaque handle to TB passed to callback\n\n Returns: number of instructions in this block"]
    pub fn qemu_plugin_tb_n_insns(tb: *const qemu_plugin_tb) -> usize;
}
extern "C" {
    #[doc = " qemu_plugin_tb_vaddr() - query helper for vaddr of TB start\n @tb: opaque handle to TB passed to callback\n\n Returns: virtual address of block start"]
    pub fn qemu_plugin_tb_vaddr(tb: *const qemu_plugin_tb) -> u64;
}
extern "C" {
    #[doc = " qemu_plugin_tb_get_insn() - retrieve handle for instruction\n @tb: opaque handle to TB passed to callback\n @idx: instruction number, 0 indexed\n\n The returned handle can be used in follow up helper queries as well\n as when instrumenting an instruction. It is only valid for the\n lifetime of the callback.\n\n Returns: opaque handle to instruction"]
    pub fn qemu_plugin_tb_get_insn(tb: *const qemu_plugin_tb, idx: usize) -> *mut qemu_plugin_insn;
}
extern "C" {
    #[doc = " qemu_plugin_insn_data() - return ptr to instruction data\n @insn: opaque instruction handle from qemu_plugin_tb_get_insn()\n\n Note: data is only valid for duration of callback. See\n qemu_plugin_insn_size() to calculate size of stream.\n\n Returns: pointer to a stream of bytes containing the value of this\n instructions opcode."]
    pub fn qemu_plugin_insn_data(insn: *const qemu_plugin_insn) -> *const ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " qemu_plugin_insn_size() - return size of instruction\n @insn: opaque instruction handle from qemu_plugin_tb_get_insn()\n\n Returns: size of instruction in bytes"]
    pub fn qemu_plugin_insn_size(insn: *const qemu_plugin_insn) -> usize;
}
extern "C" {
    #[doc = " qemu_plugin_insn_vaddr() - return vaddr of instruction\n @insn: opaque instruction handle from qemu_plugin_tb_get_insn()\n\n Returns: virtual address of instruction"]
    pub fn qemu_plugin_insn_vaddr(insn: *const qemu_plugin_insn) -> u64;
}
extern "C" {
    #[doc = " qemu_plugin_insn_haddr() - return hardware addr of instruction\n @insn: opaque instruction handle from qemu_plugin_tb_get_insn()\n\n Returns: hardware (physical) target address of instruction"]
    pub fn qemu_plugin_insn_haddr(insn: *const qemu_plugin_insn) -> *mut ::std::os::raw::c_void;
}
#[doc = " typedef qemu_plugin_meminfo_t - opaque memory transaction handle\n\n This can be further queried using the qemu_plugin_mem_* query\n functions."]
pub type qemu_plugin_meminfo_t = u32;
#[doc = " struct qemu_plugin_hwaddr - opaque hw address handle"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qemu_plugin_hwaddr {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " qemu_plugin_mem_size_shift() - get size of access\n @info: opaque memory transaction handle\n\n Returns: size of access in ^2 (0=byte, 1=16bit, 2=32bit etc...)"]
    pub fn qemu_plugin_mem_size_shift(info: qemu_plugin_meminfo_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " qemu_plugin_mem_is_sign_extended() - was the access sign extended\n @info: opaque memory transaction handle\n\n Returns: true if it was, otherwise false"]
    pub fn qemu_plugin_mem_is_sign_extended(info: qemu_plugin_meminfo_t) -> bool;
}
extern "C" {
    #[doc = " qemu_plugin_mem_is_big_endian() - was the access big endian\n @info: opaque memory transaction handle\n\n Returns: true if it was, otherwise false"]
    pub fn qemu_plugin_mem_is_big_endian(info: qemu_plugin_meminfo_t) -> bool;
}
extern "C" {
    #[doc = " qemu_plugin_mem_is_store() - was the access a store\n @info: opaque memory transaction handle\n\n Returns: true if it was, otherwise false"]
    pub fn qemu_plugin_mem_is_store(info: qemu_plugin_meminfo_t) -> bool;
}
extern "C" {
    #[doc = " qemu_plugin_get_hwaddr() - return handle for memory operation\n @info: opaque memory info structure\n @vaddr: the virtual address of the memory operation\n\n For system emulation returns a qemu_plugin_hwaddr handle to query\n details about the actual physical address backing the virtual\n address. For linux-user guests it just returns NULL.\n\n This handle is *only* valid for the duration of the callback. Any\n information about the handle should be recovered before the\n callback returns."]
    pub fn qemu_plugin_get_hwaddr(
        info: qemu_plugin_meminfo_t,
        vaddr: u64,
    ) -> *mut qemu_plugin_hwaddr;
}
extern "C" {
    #[doc = " qemu_plugin_hwaddr_is_io() - query whether memory operation is IO\n @haddr: address handle from qemu_plugin_get_hwaddr()\n\n Returns true if the handle's memory operation is to memory-mapped IO, or\n false if it is to RAM"]
    pub fn qemu_plugin_hwaddr_is_io(haddr: *const qemu_plugin_hwaddr) -> bool;
}
extern "C" {
    #[doc = " qemu_plugin_hwaddr_phys_addr() - query physical address for memory operation\n @haddr: address handle from qemu_plugin_get_hwaddr()\n\n Returns the physical address associated with the memory operation\n\n Note that the returned physical address may not be unique if you are dealing\n with multiple address spaces."]
    pub fn qemu_plugin_hwaddr_phys_addr(haddr: *const qemu_plugin_hwaddr) -> u64;
}
extern "C" {
    pub fn qemu_plugin_hwaddr_device_name(
        h: *const qemu_plugin_hwaddr,
    ) -> *const ::std::os::raw::c_char;
}
#[doc = " typedef qemu_plugin_vcpu_mem_cb_t - memory callback function type\n @vcpu_index: the executing vCPU\n @info: an opaque handle for further queries about the memory\n @vaddr: the virtual address of the transaction\n @userdata: any user data attached to the callback"]
pub type qemu_plugin_vcpu_mem_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        vcpu_index: ::std::os::raw::c_uint,
        info: qemu_plugin_meminfo_t,
        vaddr: u64,
        userdata: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " qemu_plugin_register_vcpu_mem_cb() - register memory access callback\n @insn: handle for instruction to instrument\n @cb: callback of type qemu_plugin_vcpu_mem_cb_t\n @flags: (currently unused) callback flags\n @rw: monitor reads, writes or both\n @userdata: opaque pointer for userdata\n\n This registers a full callback for every memory access generated by\n an instruction. If the instruction doesn't access memory no\n callback will be made.\n\n The callback reports the vCPU the access took place on, the virtual\n address of the access and a handle for further queries. The user\n can attach some userdata to the callback for additional purposes.\n\n Other execution threads will continue to execute during the\n callback so the plugin is responsible for ensuring it doesn't get\n confused by making appropriate use of locking if required."]
    pub fn qemu_plugin_register_vcpu_mem_cb(
        insn: *mut qemu_plugin_insn,
        cb: qemu_plugin_vcpu_mem_cb_t,
        flags: qemu_plugin_cb_flags,
        rw: qemu_plugin_mem_rw,
        userdata: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " qemu_plugin_register_vcpu_mem_inline() - register an inline op to any memory access\n @insn: handle for instruction to instrument\n @rw: apply to reads, writes or both\n @op: the op, of type qemu_plugin_op\n @ptr: pointer memory for the op\n @imm: immediate data for @op\n\n This registers a inline op every memory access generated by the\n instruction. This provides for a lightweight but not thread-safe\n way of counting the number of operations done."]
    pub fn qemu_plugin_register_vcpu_mem_inline(
        insn: *mut qemu_plugin_insn,
        rw: qemu_plugin_mem_rw,
        op: qemu_plugin_op,
        ptr: *mut ::std::os::raw::c_void,
        imm: u64,
    );
}
pub type qemu_plugin_vcpu_syscall_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        id: qemu_plugin_id_t,
        vcpu_index: ::std::os::raw::c_uint,
        num: i64,
        a1: u64,
        a2: u64,
        a3: u64,
        a4: u64,
        a5: u64,
        a6: u64,
        a7: u64,
        a8: u64,
    ),
>;
extern "C" {
    pub fn qemu_plugin_register_vcpu_syscall_cb(
        id: qemu_plugin_id_t,
        cb: qemu_plugin_vcpu_syscall_cb_t,
    );
}
pub type qemu_plugin_vcpu_syscall_ret_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        id: qemu_plugin_id_t,
        vcpu_idx: ::std::os::raw::c_uint,
        num: i64,
        ret: i64,
    ),
>;
extern "C" {
    pub fn qemu_plugin_register_vcpu_syscall_ret_cb(
        id: qemu_plugin_id_t,
        cb: qemu_plugin_vcpu_syscall_ret_cb_t,
    );
}
extern "C" {
    #[doc = " qemu_plugin_insn_disas() - return disassembly string for instruction\n @insn: instruction reference\n\n Returns an allocated string containing the disassembly"]
    pub fn qemu_plugin_insn_disas(insn: *const qemu_plugin_insn) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " qemu_plugin_insn_symbol() - best effort symbol lookup\n @insn: instruction reference\n\n Return a static string referring to the symbol. This is dependent\n on the binary QEMU is running having provided a symbol table."]
    pub fn qemu_plugin_insn_symbol(insn: *const qemu_plugin_insn) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " qemu_plugin_vcpu_for_each() - iterate over the existing vCPU\n @id: plugin ID\n @cb: callback function\n\n The @cb function is called once for each existing vCPU.\n\n See also: qemu_plugin_register_vcpu_init_cb()"]
    pub fn qemu_plugin_vcpu_for_each(id: qemu_plugin_id_t, cb: qemu_plugin_vcpu_simple_cb_t);
}
extern "C" {
    pub fn qemu_plugin_register_flush_cb(id: qemu_plugin_id_t, cb: qemu_plugin_simple_cb_t);
}
extern "C" {
    #[doc = " qemu_plugin_register_atexit_cb() - register exit callback\n @id: plugin ID\n @cb: callback\n @userdata: user data for callback\n\n The @cb function is called once execution has finished. Plugins\n should be able to free all their resources at this point much like\n after a reset/uninstall callback is called.\n\n In user-mode it is possible a few un-instrumented instructions from\n child threads may run before the host kernel reaps the threads."]
    pub fn qemu_plugin_register_atexit_cb(
        id: qemu_plugin_id_t,
        cb: qemu_plugin_udata_cb_t,
        userdata: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn qemu_plugin_n_vcpus() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qemu_plugin_n_max_vcpus() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " qemu_plugin_outs() - output string via QEMU's logging system\n @string: a string"]
    pub fn qemu_plugin_outs(string: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " qemu_plugin_bool_parse() - parses a boolean argument in the form of\n \"<argname>=[on|yes|true|off|no|false]\"\n\n @name: argument name, the part before the equals sign\n @val: argument value, what's after the equals sign\n @ret: output return value\n\n returns true if the combination @name=@val parses correctly to a boolean\n argument, and false otherwise"]
    pub fn qemu_plugin_bool_parse(
        name: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
        ret: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = " qemu_plugin_path_to_binary() - path to binary file being executed\n\n Return a string representing the path to the binary. For user-mode\n this is the main executable. For system emulation we currently\n return NULL. The user should g_free() the string once no longer\n needed."]
    pub fn qemu_plugin_path_to_binary() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " qemu_plugin_start_code() - returns start of text segment\n\n Returns the nominal start address of the main text segment in\n user-mode. Currently returns 0 for system emulation."]
    pub fn qemu_plugin_start_code() -> u64;
}
extern "C" {
    #[doc = " qemu_plugin_end_code() - returns end of text segment\n\n Returns the nominal end address of the main text segment in\n user-mode. Currently returns 0 for system emulation."]
    pub fn qemu_plugin_end_code() -> u64;
}
extern "C" {
    #[doc = " qemu_plugin_entry_code() - returns start address for module\n\n Returns the nominal entry address of the main text segment in\n user-mode. Currently returns 0 for system emulation."]
    pub fn qemu_plugin_entry_code() -> u64;
}
extern "C" {
    pub fn qemu_plugin_is_userland(insn: *const qemu_plugin_insn) -> bool;
}
extern "C" {
    pub fn qemu_plugin_get_asid(insn: *const qemu_plugin_insn) -> u16;
}
extern "C" {
    #[doc = " qemu_plugin_set_running_flag() - setting the \"running\" flag of the current CPU\n\n @is_running: The value of the flag.\n\n Some synchronization mechanism (e.g., exclusive execution) checks\n this flag to make sure all CPUs are not executing instructions and\n wait for all CPUs to be idle.\n\n In you plugin are using locks and synchronization which can block\n execution, you should set the running flag to false before being\n blocked to avoid deadlocks."]
    pub fn qemu_plugin_set_running_flag(is_running: bool);
}
extern "C" {
    #[doc = " qemu_plugin_is_current_cpu_can_run() - check whether the current CPU can\n still continue to run instructions, i.e., not stopped by other threads like quitting.\n\n Returns true if the current cpu can still run.\n\n This function is a wrapper of function `cpu_can_run`."]
    pub fn qemu_plugin_is_current_cpu_can_run() -> bool;
}
extern "C" {
    #[doc = " qemu_plugin_advance_vm_time() - advance VM time by a given bias, in nano second scale.\n\n @advanced_value: The amount of time (in nano second) to add to the VM clock.\n\n This function only has effect when timers_state.vm_clock_remote_master_enable is set to true. (See cpu-timer.c, line 85)"]
    pub fn qemu_plugin_advance_vm_time(advanced_value: i64);
}
extern "C" {
    #[doc = " qemu_plugin_register_virtual_time_cb() - register the method for CPU to calculate the time.\n\n @callback: The callback to provide virtual time"]
    pub fn qemu_plugin_register_virtual_time_cb(
        callback: ::std::option::Option<unsafe extern "C" fn() -> i64>,
    );
}
extern "C" {
    #[doc = " qemu_plugin_get_cpu_clock() - return the CPU clock time calculated by the realtime elapsing.\n\n Useful when defining the new virtual time function."]
    pub fn qemu_plugin_get_cpu_clock() -> i64;
}
extern "C" {
    #[doc = " qemu_plugin_get_snapshoted_vm_clock() - return the VM clock time when the snapshot is taken.\n\n Useful when defining the new virtual time function."]
    pub fn qemu_plugin_get_snapshoted_vm_clock() -> i64;
}
extern "C" {
    #[doc = " qemu_plugin_cpu_is_tick_enabled() - return whether the CPU tick is enabled.\n\n Useful when defining the new virtual time function."]
    pub fn qemu_plugin_cpu_is_tick_enabled() -> bool;
}
